(ql:quickload "alexandria")

(defun sort-and-unique-aux (sorted last done)
  (if sorted
      (let ((head (car sorted))
            (tail (cdr sorted)))
        (if (= last head)
            (sort-and-unique-aux tail last done)
            (sort-and-unique-aux tail head (cons head done))))
      done))

(defun sort-and-unique (list)
  (if list
      (let* ((sorted (sort (copy-list list) #'<))
             (last (car sorted)))
        (nreverse (sort-and-unique-aux (cdr sorted) last (list last))))
      nil))

(defun compress-segments (segments)
  (let* ((interesting-points (sort-and-unique (alexandria:flatten segments)))
         (n (length interesting-points))
         (decompress (make-array n :initial-contents interesting-points))
         (mapping (make-hash-table)))
    (dotimes (i n)
      (setf (gethash (aref decompress i) mapping) i))

    (let ((compressed-segments
           (mapcar #'(lambda (segment)
                       (mapcar #'(lambda (side) (gethash side mapping)) segment))
                   segments)))
      (values compressed-segments decompress))))
                                   
(defun open-left-to-right (starts ends n)
  (let ((open (make-array n))
        (current 0))
    (dotimes (i n open)
      (do ()
          ((or (not starts)
               (> (car starts) i)))
        (setf starts (cdr starts))
        (incf current))
      (setf (aref open i) current)
      (do ()
          ((or (not ends)
               (> (car ends) i)))
        (setf ends (cdr ends))
        (decf current)))))

(defun compare-segments (a b)
  (let ((a-start (car a))
        (a-end (cadr a))
        (b-start (car b))
        (b-end (cadr b)))
    (or (> a-start b-start)
        (and (= a-start b-start)
             (> a-end b-end)))))

(defun open-right-to-left (segments n)
  (let ((segments (sort (copy-list segments) #'compare-segments))
        (acu (make-array n :initial-element 0))
        (bests (make-array n :initial-element 0))
        (bests-at (make-array n :initial-element 0))
        (best 0)
        (best-at n))
    (do ((i (1- n) (1- i)))
        ((< i 0))
      (do ()
          ((or (not segments)
               (< (caar segments) i)))
        (let* ((segment (car segments))
               (start (car segment))
               (end (cadr segment)))
          (do ((i start (1+ i)))
              ((> i end))
            (incf (aref acu i))
            (when (> (aref acu i) best)
              (setf best (aref acu i)
                    best-at i))))
        (setf segments (cdr segments)))
      (setf (aref bests i) best)
      (setf (aref bests-at i) best-at))
    (values bests bests-at)))
  
(defun find-two-best (segments)
  (multiple-value-bind (segments decompress) (compress-segments segments)
    (let* ((n (length decompress))
           (starts (sort (mapcar #'(lambda (s) (car s)) segments) #'<))
           (ends (sort (mapcar #'(lambda (s) (cadr s)) segments) #'<))
           (open-l2r (open-left-to-right starts ends n)))
      (multiple-value-bind (best-r2l best-at-r2l) (open-right-to-left segments n)
        (let ((best-a 0)
              (best-b 0)
              (best (aref open-l2r 0)))
          (dotimes (i (1- n))
            (let ((sum (+ (aref open-l2r i)
                          (aref best-r2l (1+ i)))))
              (when (> sum best)
                (setf best-a i
                      best-b (aref best-at-r2l (1+ i))
                      best sum))))
          (values (aref decompress best-a)
                  (aref decompress best-b)
                  best))))))

(find-two-best '((2 3) (1 3) (1 5) (3 4) (4 5)))
