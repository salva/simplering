(defvar *ops* 0)

(defun find-max-divisor (v)
  (let* ((ops0 *ops*)
         (v (sort v #'<))
         (n (length v))
         (next-div (make-array n :fill-pointer 0))
         (heap (make-array n :fill-pointer 0)))

    (format t "~a~%" (list :v v))
    (labels ((heap-insert (vix)
             (let* ((div (aref next-div vix))
                    (pivot (vector-push-extend nil heap)))
               (do () ((= pivot 0))
                 (incf *ops*)
                 (let* ((parent (floor (1- pivot) 2))
                        (parent-vix (aref heap parent)))
                   (if (> div (aref next-div parent-vix))
                       (setf (aref heap pivot) parent-vix
                             pivot parent)
                       (return))))
               (setf (aref heap pivot) vix)))

             (heap-peek ()
               (aref heap 0))

             (heap-sink ()
               (let* ((vix (aref heap 0))
                      (div (aref next-div vix))
                      (n (length heap))
                      (pivot 0))
                 (loop
                    (incf *ops*)
                    (let ((swap (1+ (* pivot 2))))
                      (when (>= swap n) (return))
                      (let* ((swap-vix (aref heap swap))
                             (swap-div (aref next-div swap-vix))
                             (other (1+ swap)))
                        (when (< other n)
                          (let* ((other-vix (aref heap other))
                                 (other-div (aref next-div other-vix)))
                            (when (> other-div swap-div)
                              (setf swap other
                                    swap-vix other-vix
                                    swap-div other-div))))
                        (if (> swap-div div)
                            (setf (aref heap pivot) swap-vix
                                  pivot swap)
                            (return)))))
                 (setf (aref heap pivot) vix)))
             
             (heap-pop ()
               (let ((last (vector-pop heap)))
                 (if (> (length heap) 0)
                     (let ((top (aref heap 0)))
                       (setf (aref heap 0) last)
                       (heap-sink)
                       top)
                     last)))

             (heap-empty ()
               (= (length heap) 0))

             (binary-search (next top)
               (do ((a -1) (b (1- top)))
                   ((>= a b) (if (>= a 0) a nil))
                 (incf *ops*)
                 (let* ((pivot (ceiling (+ a b) 2))
                        (w (aref v pivot)))
                   (if (> w next)
                       (setf b (1- pivot))
                       (setf a pivot))))))

      (disassemble #'binary-search)
      
      (dotimes (div (1- n))
        (incf *ops*)
        (let ((vix (1+ div)))
          (setf (aref next-div vix) div)
          (heap-insert vix)))

      (do ()
          ((heap-empty))
        (incf *ops*)
        (let* ((vix (heap-peek))
               (div (aref next-div vix))
               (w (aref v vix))
               (divw (aref v div))
               (r (floor w divw)))
          ; (format t "~a~%" (list :vix vix :div div :w w :divw divw :r r))
          (if (= (* r divw) w)
              (progn
                (format t "~a divides ~a, ops: ~a~%" divw w (- *ops* ops0))
                (heap-pop))
              (if (> (* divw divw) w)
                  (let* ((next (floor w (1+ r)))
                         (div (binary-search next div)))
                    ; (format t "~a~%" (list :next next :div div))
                    (if div
                        (progn
                          (setf (aref next-div vix) div)
                          (heap-sink))
                        (heap-pop)))
                  (if (> div 0)
                      (progn
                        (setf (aref next-div vix) (1- div))
                        (heap-sink))
                      (heap-pop)))))))
  (- *ops* ops0)))

                  

(defun test-maxdiv (n maxw)
  (let ((v (make-array n)))
    (dotimes (i n)
      (setf (aref v i) (1+ (random maxw))))
    (find-max-divisor v)))
